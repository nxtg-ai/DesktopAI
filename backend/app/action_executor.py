from __future__ import annotations

import asyncio
from dataclasses import dataclass
from datetime import datetime, timezone
import os
import shutil
import subprocess
import sys
from typing import Any, Dict, Optional

from .schemas import TaskAction


def _is_windows_platform() -> bool:
    return os.name == "nt" or sys.platform.startswith("win")


@dataclass(frozen=True)
class ActionExecutionResult:
    ok: bool
    result: Dict[str, Any]
    error: Optional[str] = None


class TaskActionExecutor:
    mode: str = "simulated"

    async def execute(self, action: TaskAction, *, objective: str) -> ActionExecutionResult:
        raise NotImplementedError

    def status(self) -> Dict[str, Any]:
        raise NotImplementedError

    async def preflight(self) -> Dict[str, Any]:
        status = self.status()
        available = bool(status.get("available", False))
        mode = str(status.get("mode", self.mode))
        ok = available or mode == "simulated"
        return {
            "mode": mode,
            "ok": ok,
            "checks": [
                {
                    "name": "executor_available",
                    "ok": ok,
                    "detail": status.get("message", ""),
                }
            ],
            "message": status.get("message", ""),
        }


class SimulatedTaskActionExecutor(TaskActionExecutor):
    mode = "simulated"

    async def execute(self, action: TaskAction, *, objective: str) -> ActionExecutionResult:
        return ActionExecutionResult(
            ok=True,
            result={
                "executor": "backend-simulated",
                "mode": self.mode,
                "action": action.action,
                "objective": objective,
                "ok": True,
            },
        )

    def status(self) -> Dict[str, Any]:
        return {
            "mode": self.mode,
            "available": True,
            "message": "Simulated deterministic executor active.",
        }

    async def preflight(self) -> Dict[str, Any]:
        return {
            "mode": self.mode,
            "ok": True,
            "checks": [
                {
                    "name": "simulated_mode",
                    "ok": True,
                    "detail": "Deterministic simulated executor active.",
                }
            ],
            "message": "Simulated executor ready.",
        }


class WindowsPowerShellActionExecutor(TaskActionExecutor):
    mode = "windows-powershell"

    def __init__(
        self,
        powershell_executable: str = "powershell.exe",
        timeout_s: int = 20,
        default_compose_text: str = "Draft generated by DesktopAI.",
    ) -> None:
        self._timeout_s = max(1, int(timeout_s))
        self._default_compose_text = default_compose_text.strip() or "Draft generated by DesktopAI."
        self._is_windows = _is_windows_platform()
        self._powershell = self._resolve_powershell(powershell_executable)

    def _resolve_powershell(self, preferred: str) -> Optional[str]:
        candidates = [preferred, "powershell.exe", "pwsh.exe", "powershell", "pwsh"]
        for candidate in candidates:
            if not candidate:
                continue
            resolved = shutil.which(candidate)
            if resolved:
                return resolved
        return None

    async def execute(self, action: TaskAction, *, objective: str) -> ActionExecutionResult:
        if not self._is_windows:
            return ActionExecutionResult(
                ok=False,
                error="windows powershell executor requires Windows host",
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        if not self._powershell:
            return ActionExecutionResult(
                ok=False,
                error="powershell executable not found",
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        try:
            output = await self._execute_action(action, objective=objective)
        except Exception as exc:
            return ActionExecutionResult(
                ok=False,
                error=str(exc),
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        return ActionExecutionResult(
            ok=True,
            result={
                "executor": self.mode,
                "mode": self.mode,
                "action": action.action,
                "ok": True,
                "output": output,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            },
        )

    async def _execute_action(self, action: TaskAction, *, objective: str) -> str:
        name = (action.action or "").strip()
        params = dict(action.parameters or {})

        if name == "observe_desktop":
            script = (
                "$ErrorActionPreference='Stop'; "
                "Add-Type -TypeDefinition \"using System;using System.Runtime.InteropServices;"
                "using System.Text;public static class U32{[DllImport('user32.dll')]public static extern IntPtr GetForegroundWindow();"
                "[DllImport('user32.dll',SetLastError=true)]public static extern int GetWindowText(IntPtr hWnd,StringBuilder text,int count);}\"\n"
                "$h=[U32]::GetForegroundWindow();$sb=New-Object System.Text.StringBuilder 1024;"
                "[void][U32]::GetWindowText($h,$sb,$sb.Capacity);$sb.ToString()"
            )
            return await self._run_powershell(script)

        if name == "open_application":
            app = str(params.get("application", "")).strip() or "outlook.exe"
            app = self._map_application_alias(app)
            script = (
                "$ErrorActionPreference='Stop'; "
                f"Start-Process -FilePath {self._ps_quote(app)}; "
                "Start-Sleep -Milliseconds 600; "
                f"Write-Output {self._ps_quote(f'started:{app}')}"
            )
            return await self._run_powershell(script)

        if name == "focus_search":
            keys = str(params.get("keys", "^f"))
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "compose_text":
            text = str(params.get("text", "")).strip()
            if not text:
                text = f"{self._default_compose_text} ({objective})"
            keys = self._encode_sendkeys_text(text)
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "send_or_submit":
            keys = str(params.get("keys", "^{ENTER}"))
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "verify_outcome":
            script = "$ErrorActionPreference='Stop'; Start-Sleep -Milliseconds 200; Write-Output 'verified'"
            return await self._run_powershell(script)

        raise RuntimeError(f"unsupported action for windows executor: {name}")

    def _send_keys_script(self, keys: str) -> str:
        return (
            "$ErrorActionPreference='Stop'; "
            "$ws=New-Object -ComObject WScript.Shell; "
            "Start-Sleep -Milliseconds 150; "
            f"$ws.SendKeys({self._ps_quote(keys)}); "
            f"Write-Output {self._ps_quote(f'sent-keys:{keys}')}"
        )

    def _run_powershell_blocking(self, script: str) -> str:
        if not self._powershell:
            raise RuntimeError("powershell executable not found")
        proc = subprocess.run(
            [
                self._powershell,
                "-NoProfile",
                "-NonInteractive",
                "-ExecutionPolicy",
                "Bypass",
                "-Command",
                script,
            ],
            capture_output=True,
            text=True,
            timeout=self._timeout_s,
            check=False,
        )
        stdout = (proc.stdout or "").strip()
        stderr = (proc.stderr or "").strip()
        if proc.returncode != 0:
            detail = stderr or stdout or f"exit code {proc.returncode}"
            raise RuntimeError(detail)
        return stdout

    async def _run_powershell(self, script: str) -> str:
        return await asyncio.to_thread(self._run_powershell_blocking, script)

    def _ps_quote(self, value: str) -> str:
        return "'" + value.replace("'", "''") + "'"

    def _map_application_alias(self, value: str) -> str:
        aliases = {
            "outlook": "outlook.exe",
            "vscode": "Code.exe",
            "code": "Code.exe",
            "notepad": "notepad.exe",
            "chrome": "chrome.exe",
            "edge": "msedge.exe",
            "teams": "ms-teams.exe",
        }
        key = value.strip().lower()
        return aliases.get(key, value)

    def _encode_sendkeys_text(self, text: str) -> str:
        encoded = []
        special = {"+", "^", "%", "~", "(", ")", "[", "]", "{", "}"}
        for ch in text:
            if ch == "\r":
                continue
            if ch == "\n":
                encoded.append("{ENTER}")
                continue
            if ch in special:
                encoded.append(f"{{{ch}}}")
                continue
            encoded.append(ch)
        return "".join(encoded)

    def status(self) -> Dict[str, Any]:
        available = self._is_windows and self._powershell is not None
        if not self._is_windows:
            message = "Windows-only executor unavailable on non-Windows host."
        elif self._powershell:
            message = "Windows PowerShell executor ready."
        else:
            message = "Windows PowerShell executor unavailable."

        return {
            "mode": self.mode,
            "available": available,
            "powershell": self._powershell,
            "timeout_s": self._timeout_s,
            "message": message,
        }

    async def preflight(self) -> Dict[str, Any]:
        checks: list[Dict[str, Any]] = []

        windows_ok = bool(self._is_windows)
        checks.append(
            {
                "name": "windows_host",
                "ok": windows_ok,
                "detail": "Windows host detected." if windows_ok else "Non-Windows host detected.",
            }
        )
        if not windows_ok:
            return {
                "mode": self.mode,
                "ok": False,
                "checks": checks,
                "message": "Windows preflight failed: non-Windows host.",
            }

        powershell_ok = self._powershell is not None
        checks.append(
            {
                "name": "powershell_available",
                "ok": powershell_ok,
                "detail": self._powershell or "PowerShell executable not found.",
            }
        )
        if not powershell_ok:
            return {
                "mode": self.mode,
                "ok": False,
                "checks": checks,
                "message": "Windows preflight failed: PowerShell not available.",
            }

        async def _run_check(name: str, script: str, success_detail: str) -> None:
            try:
                output = await self._run_powershell(script)
                checks.append(
                    {
                        "name": name,
                        "ok": True,
                        "detail": output or success_detail,
                    }
                )
            except Exception as exc:
                checks.append(
                    {
                        "name": name,
                        "ok": False,
                        "detail": str(exc),
                    }
                )

        await _run_check(
            "powershell_roundtrip",
            "$ErrorActionPreference='Stop'; Write-Output 'desktopai-preflight-ok'",
            "PowerShell command roundtrip succeeded.",
        )
        await _run_check(
            "wscript_shell_com",
            (
                "$ErrorActionPreference='Stop'; "
                "$ws=New-Object -ComObject WScript.Shell; "
                "if ($null -eq $ws) { throw 'WScript.Shell unavailable' }; "
                "Write-Output 'wscript-shell-ok'"
            ),
            "WScript.Shell COM available.",
        )

        ok = all(bool(item.get("ok")) for item in checks)
        return {
            "mode": self.mode,
            "ok": ok,
            "checks": checks,
            "message": "Windows preflight passed." if ok else "Windows preflight failed.",
        }


def build_action_executor(
    mode: str,
    powershell_executable: str,
    timeout_s: int,
    default_compose_text: str = "Draft generated by DesktopAI.",
    cdp_endpoint: str = "http://localhost:9222",
) -> TaskActionExecutor:
    normalized = (mode or "").strip().lower()
    if normalized in {"sim", "simulate", "simulated"}:
        return SimulatedTaskActionExecutor()

    if normalized in {"windows", "windows-powershell", "powershell"}:
        return WindowsPowerShellActionExecutor(
            powershell_executable=powershell_executable,
            timeout_s=timeout_s,
            default_compose_text=default_compose_text,
        )

    if normalized in {"playwright", "browser", "playwright-cdp"}:
        try:
            from .playwright_executor import PlaywrightExecutor
            return PlaywrightExecutor(cdp_endpoint=cdp_endpoint)
        except ImportError as exc:
            raise ValueError(
                f"Playwright executor mode requested but playwright not installed: {exc}"
            ) from exc

    if normalized in {"auto", ""}:
        if not _is_windows_platform():
            return SimulatedTaskActionExecutor()

        windows = WindowsPowerShellActionExecutor(
            powershell_executable=powershell_executable,
            timeout_s=timeout_s,
            default_compose_text=default_compose_text,
        )
        if windows.status().get("available"):
            return windows
        return SimulatedTaskActionExecutor()

    raise ValueError(f"unsupported ACTION_EXECUTOR_MODE: {mode}")


def build_action_executors(
    mode: str,
    powershell_executable: str,
    timeout_s: int,
    default_compose_text: str = "Draft generated by DesktopAI.",
    cdp_endpoint: str = "http://localhost:9222",
) -> dict[str, TaskActionExecutor]:
    """Build all available action executors.

    Args:
        mode: Primary executor mode
        powershell_executable: Path to PowerShell executable
        timeout_s: Execution timeout in seconds
        default_compose_text: Default text for compose actions
        cdp_endpoint: Chrome DevTools Protocol endpoint for Playwright

    Returns:
        Dict mapping executor names to executor instances
    """
    executors: dict[str, TaskActionExecutor] = {}

    # Build primary executor
    executors["primary"] = build_action_executor(
        mode=mode,
        powershell_executable=powershell_executable,
        timeout_s=timeout_s,
        default_compose_text=default_compose_text,
        cdp_endpoint=cdp_endpoint,
    )

    # Try to add browser executor
    try:
        from .playwright_executor import PlaywrightExecutor
        executors["browser"] = PlaywrightExecutor(cdp_endpoint=cdp_endpoint)
    except ImportError:
        pass

    return executors
