from __future__ import annotations

import asyncio
from dataclasses import dataclass
from datetime import datetime, timezone
import json
import logging
import os
import shutil
import subprocess
import sys
from typing import Any, Dict, Optional

from .schemas import TaskAction

logger = logging.getLogger(__name__)

# TYPE_CHECKING avoids circular import at runtime
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .desktop_context import DesktopContext


def _is_windows_platform() -> bool:
    return os.name == "nt" or sys.platform.startswith("win")


@dataclass(frozen=True)
class ActionExecutionResult:
    ok: bool
    result: Dict[str, Any]
    error: Optional[str] = None


class TaskActionExecutor:
    mode: str = "simulated"

    async def execute(
        self,
        action: TaskAction,
        *,
        objective: str,
        desktop_context: Optional[DesktopContext] = None,
    ) -> ActionExecutionResult:
        raise NotImplementedError

    def status(self) -> Dict[str, Any]:
        raise NotImplementedError

    async def preflight(self) -> Dict[str, Any]:
        status = self.status()
        available = bool(status.get("available", False))
        mode = str(status.get("mode", self.mode))
        ok = available or mode == "simulated"
        return {
            "mode": mode,
            "ok": ok,
            "checks": [
                {
                    "name": "executor_available",
                    "ok": ok,
                    "detail": status.get("message", ""),
                }
            ],
            "message": status.get("message", ""),
        }


class SimulatedTaskActionExecutor(TaskActionExecutor):
    mode = "simulated"

    async def execute(
        self,
        action: TaskAction,
        *,
        objective: str,
        desktop_context: Optional[DesktopContext] = None,
    ) -> ActionExecutionResult:
        return ActionExecutionResult(
            ok=True,
            result={
                "executor": "backend-simulated",
                "mode": self.mode,
                "action": action.action,
                "objective": objective,
                "ok": True,
            },
        )

    def status(self) -> Dict[str, Any]:
        return {
            "mode": self.mode,
            "available": True,
            "message": "Simulated deterministic executor active.",
        }

    async def preflight(self) -> Dict[str, Any]:
        return {
            "mode": self.mode,
            "ok": True,
            "checks": [
                {
                    "name": "simulated_mode",
                    "ok": True,
                    "detail": "Deterministic simulated executor active.",
                }
            ],
            "message": "Simulated executor ready.",
        }


class WindowsPowerShellActionExecutor(TaskActionExecutor):
    mode = "windows-powershell"

    def __init__(
        self,
        powershell_executable: str = "powershell.exe",
        timeout_s: int = 20,
        default_compose_text: str = "Draft generated by DesktopAI.",
        state_store=None,
        ollama=None,
    ) -> None:
        self._timeout_s = max(1, int(timeout_s))
        self._default_compose_text = default_compose_text.strip() or "Draft generated by DesktopAI."
        self._is_windows = _is_windows_platform()
        self._powershell = self._resolve_powershell(powershell_executable)
        self._state_store = state_store
        self._ollama = ollama

    def _resolve_powershell(self, preferred: str) -> Optional[str]:
        candidates = [preferred, "powershell.exe", "pwsh.exe", "powershell", "pwsh"]
        for candidate in candidates:
            if not candidate:
                continue
            resolved = shutil.which(candidate)
            if resolved:
                return resolved
        return None

    async def execute(
        self,
        action: TaskAction,
        *,
        objective: str,
        desktop_context: Optional[DesktopContext] = None,
    ) -> ActionExecutionResult:
        if not self._is_windows:
            return ActionExecutionResult(
                ok=False,
                error="windows powershell executor requires Windows host",
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        if not self._powershell:
            return ActionExecutionResult(
                ok=False,
                error="powershell executable not found",
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        try:
            output = await self._execute_action(action, objective=objective, desktop_context=desktop_context)
        except Exception as exc:
            return ActionExecutionResult(
                ok=False,
                error=str(exc),
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        return ActionExecutionResult(
            ok=True,
            result={
                "executor": self.mode,
                "mode": self.mode,
                "action": action.action,
                "ok": True,
                "output": output,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            },
        )

    async def _execute_action(
        self,
        action: TaskAction,
        *,
        objective: str,
        desktop_context: Optional[DesktopContext] = None,
    ) -> str:
        name = (action.action or "").strip()
        params = dict(action.parameters or {})

        if name == "observe_desktop":
            if desktop_context is not None:
                return json.dumps({
                    "window_title": desktop_context.window_title,
                    "process": desktop_context.process_exe,
                    "uia_summary": desktop_context.uia_summary,
                    "screenshot_available": desktop_context.screenshot_b64 is not None,
                })
            script = (
                "$ErrorActionPreference='Stop'; "
                "Add-Type -TypeDefinition \"using System;using System.Runtime.InteropServices;"
                "using System.Text;public static class U32{[DllImport('user32.dll')]public static extern IntPtr GetForegroundWindow();"
                "[DllImport('user32.dll',SetLastError=true)]public static extern int GetWindowText(IntPtr hWnd,StringBuilder text,int count);}\"\n"
                "$h=[U32]::GetForegroundWindow();$sb=New-Object System.Text.StringBuilder 1024;"
                "[void][U32]::GetWindowText($h,$sb,$sb.Capacity);$sb.ToString()"
            )
            return await self._run_powershell(script)

        if name == "open_application":
            app = str(params.get("application", "")).strip() or "outlook.exe"
            app = self._map_application_alias(app)
            script = (
                "$ErrorActionPreference='Stop'; "
                f"Start-Process -FilePath {self._ps_quote(app)}; "
                "Start-Sleep -Milliseconds 600; "
                f"Write-Output {self._ps_quote(f'started:{app}')}"
            )
            return await self._run_powershell(script)

        if name == "focus_search":
            keys = str(params.get("keys", "^f"))
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "compose_text":
            text = str(params.get("text", "")).strip()
            if not text and self._ollama and desktop_context:
                text = await self._generate_compose_text(objective, desktop_context) or ""
            if not text:
                text = f"{self._default_compose_text} ({objective})"
            keys = self._encode_sendkeys_text(text)
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "send_or_submit":
            keys = str(params.get("keys", "^{ENTER}"))
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "verify_outcome":
            if desktop_context and self._state_store:
                after_event = await self._state_store.current()
                if after_event:
                    from .desktop_context import DesktopContext as DC
                    after_ctx = DC.from_event(after_event)
                    if after_ctx:
                        changes = _detect_changes(desktop_context, after_ctx)
                        if changes:
                            return f"verified: {changes}"
                        return "verified: no observable state change"
            script = "$ErrorActionPreference='Stop'; Start-Sleep -Milliseconds 200; Write-Output 'verified'"
            return await self._run_powershell(script)

        raise RuntimeError(f"unsupported action for windows executor: {name}")

    async def _generate_compose_text(self, objective: str, desktop_context) -> Optional[str]:
        try:
            prompt = (
                f"Draft a concise response for the following objective.\n\n"
                f"Objective: {objective}\n\n"
                f"Desktop Context:\n{desktop_context.to_llm_prompt()}\n\n"
                f"Write only the text to type. No explanation."
            )
            messages = [{"role": "user", "content": prompt}]
            screenshot_bytes = desktop_context.get_screenshot_bytes()
            if screenshot_bytes and hasattr(self._ollama, "chat_with_images"):
                result = await self._ollama.chat_with_images(messages, [screenshot_bytes])
            elif hasattr(self._ollama, "chat"):
                result = await self._ollama.chat(messages)
            else:
                result = await self._ollama.generate(prompt)
            if result and result.strip():
                return result.strip()
        except Exception as exc:
            logger.warning("LLM compose_text failed, using default: %s", exc)
        return None

    def _send_keys_script(self, keys: str) -> str:
        return (
            "$ErrorActionPreference='Stop'; "
            "$ws=New-Object -ComObject WScript.Shell; "
            "Start-Sleep -Milliseconds 150; "
            f"$ws.SendKeys({self._ps_quote(keys)}); "
            f"Write-Output {self._ps_quote(f'sent-keys:{keys}')}"
        )

    def _run_powershell_blocking(self, script: str) -> str:
        if not self._powershell:
            raise RuntimeError("powershell executable not found")
        proc = subprocess.run(
            [
                self._powershell,
                "-NoProfile",
                "-NonInteractive",
                "-ExecutionPolicy",
                "Bypass",
                "-Command",
                script,
            ],
            capture_output=True,
            text=True,
            timeout=self._timeout_s,
            check=False,
        )
        stdout = (proc.stdout or "").strip()
        stderr = (proc.stderr or "").strip()
        if proc.returncode != 0:
            detail = stderr or stdout or f"exit code {proc.returncode}"
            raise RuntimeError(detail)
        return stdout

    async def _run_powershell(self, script: str) -> str:
        return await asyncio.to_thread(self._run_powershell_blocking, script)

    def _ps_quote(self, value: str) -> str:
        return "'" + value.replace("'", "''") + "'"

    def _map_application_alias(self, value: str) -> str:
        aliases = {
            "outlook": "outlook.exe",
            "vscode": "Code.exe",
            "code": "Code.exe",
            "notepad": "notepad.exe",
            "chrome": "chrome.exe",
            "edge": "msedge.exe",
            "teams": "ms-teams.exe",
        }
        key = value.strip().lower()
        return aliases.get(key, value)

    def _encode_sendkeys_text(self, text: str) -> str:
        encoded = []
        special = {"+", "^", "%", "~", "(", ")", "[", "]", "{", "}"}
        for ch in text:
            if ch == "\r":
                continue
            if ch == "\n":
                encoded.append("{ENTER}")
                continue
            if ch in special:
                encoded.append(f"{{{ch}}}")
                continue
            encoded.append(ch)
        return "".join(encoded)

    def status(self) -> Dict[str, Any]:
        available = self._is_windows and self._powershell is not None
        if not self._is_windows:
            message = "Windows-only executor unavailable on non-Windows host."
        elif self._powershell:
            message = "Windows PowerShell executor ready."
        else:
            message = "Windows PowerShell executor unavailable."

        return {
            "mode": self.mode,
            "available": available,
            "powershell": self._powershell,
            "timeout_s": self._timeout_s,
            "message": message,
        }

    async def preflight(self) -> Dict[str, Any]:
        checks: list[Dict[str, Any]] = []

        windows_ok = bool(self._is_windows)
        checks.append(
            {
                "name": "windows_host",
                "ok": windows_ok,
                "detail": "Windows host detected." if windows_ok else "Non-Windows host detected.",
            }
        )
        if not windows_ok:
            return {
                "mode": self.mode,
                "ok": False,
                "checks": checks,
                "message": "Windows preflight failed: non-Windows host.",
            }

        powershell_ok = self._powershell is not None
        checks.append(
            {
                "name": "powershell_available",
                "ok": powershell_ok,
                "detail": self._powershell or "PowerShell executable not found.",
            }
        )
        if not powershell_ok:
            return {
                "mode": self.mode,
                "ok": False,
                "checks": checks,
                "message": "Windows preflight failed: PowerShell not available.",
            }

        async def _run_check(name: str, script: str, success_detail: str) -> None:
            try:
                output = await self._run_powershell(script)
                checks.append(
                    {
                        "name": name,
                        "ok": True,
                        "detail": output or success_detail,
                    }
                )
            except Exception as exc:
                checks.append(
                    {
                        "name": name,
                        "ok": False,
                        "detail": str(exc),
                    }
                )

        await _run_check(
            "powershell_roundtrip",
            "$ErrorActionPreference='Stop'; Write-Output 'desktopai-preflight-ok'",
            "PowerShell command roundtrip succeeded.",
        )
        await _run_check(
            "wscript_shell_com",
            (
                "$ErrorActionPreference='Stop'; "
                "$ws=New-Object -ComObject WScript.Shell; "
                "if ($null -eq $ws) { throw 'WScript.Shell unavailable' }; "
                "Write-Output 'wscript-shell-ok'"
            ),
            "WScript.Shell COM available.",
        )

        ok = all(bool(item.get("ok")) for item in checks)
        return {
            "mode": self.mode,
            "ok": ok,
            "checks": checks,
            "message": "Windows preflight passed." if ok else "Windows preflight failed.",
        }


class BridgeActionExecutor(TaskActionExecutor):
    """Executor that sends commands to the Windows collector via CommandBridge."""

    mode = "bridge"

    def __init__(
        self,
        bridge,
        timeout_s: int = 10,
        ollama=None,
    ) -> None:
        self._bridge = bridge
        self._timeout_s = max(1, int(timeout_s))
        self._ollama = ollama

    async def execute(
        self,
        action: TaskAction,
        *,
        objective: str,
        desktop_context: Optional[DesktopContext] = None,
    ) -> ActionExecutionResult:
        if not self._bridge.connected:
            return ActionExecutionResult(
                ok=False,
                error="bridge not connected to collector",
                result={"executor": self.mode, "action": action.action, "ok": False},
            )

        name = (action.action or "").strip()
        params = dict(action.parameters or {})

        try:
            if name == "observe_desktop":
                result = await self._bridge.execute("observe", timeout_s=self._timeout_s)
            elif name == "open_application":
                result = await self._bridge.execute(
                    "open_application",
                    {"application": params.get("application", "")},
                    timeout_s=self._timeout_s,
                )
            elif name == "click":
                result = await self._bridge.execute("click", params, timeout_s=self._timeout_s)
            elif name == "type_text":
                result = await self._bridge.execute("type_text", params, timeout_s=self._timeout_s)
            elif name == "send_keys" or name == "focus_search" or name == "send_or_submit":
                keys = params.get("keys", "")
                result = await self._bridge.execute("send_keys", {"keys": keys}, timeout_s=self._timeout_s)
            elif name == "compose_text":
                text = params.get("text", "")
                if not text and self._ollama and desktop_context:
                    text = await self._generate_compose_text(objective, desktop_context)
                if text:
                    result = await self._bridge.execute(
                        "type_text", {"text": text}, timeout_s=self._timeout_s,
                    )
                else:
                    result = {"ok": False, "error": "no text to compose"}
            elif name == "focus_window":
                result = await self._bridge.execute("focus_window", params, timeout_s=self._timeout_s)
            elif name == "verify_outcome":
                result = await self._bridge.execute("observe", timeout_s=self._timeout_s)
            else:
                result = await self._bridge.execute(name, params, timeout_s=self._timeout_s)
        except Exception as exc:
            return ActionExecutionResult(
                ok=False,
                error=str(exc),
                result={"executor": self.mode, "action": name, "ok": False},
            )

        ok = bool(result.get("ok", False))
        return ActionExecutionResult(
            ok=ok,
            result={
                "executor": self.mode,
                "action": name,
                "ok": ok,
                "bridge_result": result.get("result"),
                "screenshot_available": result.get("screenshot_b64") is not None,
            },
            error=result.get("error"),
        )

    async def _generate_compose_text(self, objective: str, desktop_context) -> str:
        try:
            prompt = (
                f"Draft a concise response for the following objective.\n\n"
                f"Objective: {objective}\n\n"
                f"Desktop Context:\n{desktop_context.to_llm_prompt()}\n\n"
                f"Write only the text to type. No explanation."
            )
            messages = [{"role": "user", "content": prompt}]
            screenshot_bytes = desktop_context.get_screenshot_bytes()
            if screenshot_bytes and hasattr(self._ollama, "chat_with_images"):
                result = await self._ollama.chat_with_images(messages, [screenshot_bytes])
            elif hasattr(self._ollama, "chat"):
                result = await self._ollama.chat(messages)
            else:
                result = await self._ollama.generate(prompt)
            if result and result.strip():
                return result.strip()
        except Exception as exc:
            logger.warning("BridgeExecutor compose_text LLM failed: %s", exc)
        return ""

    def status(self) -> Dict[str, Any]:
        return {
            "mode": self.mode,
            "available": self._bridge.connected,
            "bridge_connected": self._bridge.connected,
            "timeout_s": self._timeout_s,
            "message": "Bridge executor connected." if self._bridge.connected else "Bridge executor: collector not connected.",
        }


def _detect_changes(before, after) -> Optional[str]:
    parts = []
    if before.window_title != after.window_title:
        parts.append(f"window changed to {after.window_title!r}")
    if before.uia_summary != after.uia_summary:
        parts.append("UI state changed")
    if not parts:
        return None
    return "; ".join(parts)


def build_action_executor(
    mode: str,
    powershell_executable: str,
    timeout_s: int,
    default_compose_text: str = "Draft generated by DesktopAI.",
    cdp_endpoint: str = "http://localhost:9222",
    state_store=None,
    ollama=None,
    bridge=None,
) -> TaskActionExecutor:
    normalized = (mode or "").strip().lower()
    if normalized in {"sim", "simulate", "simulated"}:
        return SimulatedTaskActionExecutor()

    if normalized in {"windows", "windows-powershell", "powershell"}:
        return WindowsPowerShellActionExecutor(
            powershell_executable=powershell_executable,
            timeout_s=timeout_s,
            default_compose_text=default_compose_text,
            state_store=state_store,
            ollama=ollama,
        )

    if normalized in {"bridge", "windows-bridge"}:
        if bridge is None:
            raise ValueError("Bridge executor mode requested but no bridge provided")
        return BridgeActionExecutor(
            bridge=bridge,
            timeout_s=timeout_s,
            ollama=ollama,
        )

    if normalized in {"playwright", "browser", "playwright-cdp"}:
        try:
            from .playwright_executor import PlaywrightExecutor
            return PlaywrightExecutor(cdp_endpoint=cdp_endpoint)
        except ImportError as exc:
            raise ValueError(
                f"Playwright executor mode requested but playwright not installed: {exc}"
            ) from exc

    if normalized in {"auto", ""}:
        if not _is_windows_platform():
            return SimulatedTaskActionExecutor()

        windows = WindowsPowerShellActionExecutor(
            powershell_executable=powershell_executable,
            timeout_s=timeout_s,
            default_compose_text=default_compose_text,
            state_store=state_store,
            ollama=ollama,
        )
        if windows.status().get("available"):
            return windows
        return SimulatedTaskActionExecutor()

    raise ValueError(f"unsupported ACTION_EXECUTOR_MODE: {mode}")


def build_action_executors(
    mode: str,
    powershell_executable: str,
    timeout_s: int,
    default_compose_text: str = "Draft generated by DesktopAI.",
    cdp_endpoint: str = "http://localhost:9222",
    state_store=None,
    ollama=None,
    bridge=None,
) -> dict[str, TaskActionExecutor]:
    """Build all available action executors.

    Args:
        mode: Primary executor mode
        powershell_executable: Path to PowerShell executable
        timeout_s: Execution timeout in seconds
        default_compose_text: Default text for compose actions
        cdp_endpoint: Chrome DevTools Protocol endpoint for Playwright
        state_store: Optional StateStore for desktop context
        ollama: Optional OllamaClient for LLM-powered actions

    Returns:
        Dict mapping executor names to executor instances
    """
    executors: dict[str, TaskActionExecutor] = {}

    # Build primary executor
    executors["primary"] = build_action_executor(
        mode=mode,
        powershell_executable=powershell_executable,
        timeout_s=timeout_s,
        default_compose_text=default_compose_text,
        cdp_endpoint=cdp_endpoint,
        state_store=state_store,
        ollama=ollama,
    )

    # Try to add browser executor
    try:
        from .playwright_executor import PlaywrightExecutor
        executors["browser"] = PlaywrightExecutor(cdp_endpoint=cdp_endpoint)
    except ImportError:
        pass

    return executors
