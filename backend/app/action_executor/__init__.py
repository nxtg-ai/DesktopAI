"""Action executor subpackage — simulated, PowerShell, bridge, and factory."""

from .base import ActionExecutionResult, TaskActionExecutor, _is_windows_platform
from .bridge import BridgeActionExecutor
from .powershell import WindowsPowerShellActionExecutor
from .simulated import SimulatedTaskActionExecutor

__all__ = [
    "ActionExecutionResult",
    "TaskActionExecutor",
    "SimulatedTaskActionExecutor",
    "WindowsPowerShellActionExecutor",
    "BridgeActionExecutor",
    "build_action_executor",
    "build_action_executors",
]


def build_action_executor(
    mode: str,
    powershell_executable: str,
    timeout_s: int,
    default_compose_text: str = "Draft generated by DesktopAI.",
    cdp_endpoint: str = "http://localhost:9222",
    state_store=None,
    ollama=None,
    bridge=None,
) -> TaskActionExecutor:
    normalized = (mode or "").strip().lower()
    if normalized in {"sim", "simulate", "simulated"}:
        return SimulatedTaskActionExecutor()

    if normalized in {"windows", "windows-powershell", "powershell"}:
        return WindowsPowerShellActionExecutor(
            powershell_executable=powershell_executable,
            timeout_s=timeout_s,
            default_compose_text=default_compose_text,
            state_store=state_store,
            ollama=ollama,
        )

    if normalized in {"bridge", "windows-bridge"}:
        if bridge is None:
            raise ValueError("Bridge executor mode requested but no bridge provided")
        return BridgeActionExecutor(
            bridge=bridge,
            timeout_s=timeout_s,
            ollama=ollama,
        )

    if normalized in {"playwright", "browser", "playwright-cdp"}:
        try:
            from ..playwright_executor import PlaywrightExecutor
            return PlaywrightExecutor(cdp_endpoint=cdp_endpoint)
        except ImportError as exc:
            raise ValueError(
                f"Playwright executor mode requested but playwright not installed: {exc}"
            ) from exc

    if normalized in {"auto", ""}:
        # Prefer bridge (works cross-platform over WebSocket to collector).
        # Don't check bridge.connected here — executor is built at startup
        # before collector connects. BridgeActionExecutor handles disconnection
        # gracefully at runtime.
        if bridge is not None:
            return BridgeActionExecutor(
                bridge=bridge, timeout_s=timeout_s, ollama=ollama,
            )
        if _is_windows_platform():
            windows = WindowsPowerShellActionExecutor(
                powershell_executable=powershell_executable,
                timeout_s=timeout_s,
                default_compose_text=default_compose_text,
                state_store=state_store,
                ollama=ollama,
            )
            if windows.status().get("available"):
                return windows
        return SimulatedTaskActionExecutor()

    raise ValueError(f"unsupported ACTION_EXECUTOR_MODE: {mode}")


def build_action_executors(
    mode: str,
    powershell_executable: str,
    timeout_s: int,
    default_compose_text: str = "Draft generated by DesktopAI.",
    cdp_endpoint: str = "http://localhost:9222",
    state_store=None,
    ollama=None,
    bridge=None,
) -> dict[str, TaskActionExecutor]:
    """Build all available action executors."""
    executors: dict[str, TaskActionExecutor] = {}

    executors["primary"] = build_action_executor(
        mode=mode,
        powershell_executable=powershell_executable,
        timeout_s=timeout_s,
        default_compose_text=default_compose_text,
        cdp_endpoint=cdp_endpoint,
        state_store=state_store,
        ollama=ollama,
        bridge=bridge,
    )

    try:
        from ..playwright_executor import PlaywrightExecutor
        executors["browser"] = PlaywrightExecutor(cdp_endpoint=cdp_endpoint)
    except ImportError:
        pass

    return executors
