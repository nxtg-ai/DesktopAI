"""Windows PowerShell action executor."""

from __future__ import annotations

import asyncio
import json
import logging
import shutil
import subprocess
from datetime import datetime, timezone
from typing import TYPE_CHECKING, Any, Dict, Optional

from ..schemas import TaskAction
from .base import ActionExecutionResult, TaskActionExecutor, _detect_changes, _is_windows_platform

if TYPE_CHECKING:
    from ..desktop_context import DesktopContext

logger = logging.getLogger(__name__)


class WindowsPowerShellActionExecutor(TaskActionExecutor):
    mode = "windows-powershell"

    def __init__(
        self,
        powershell_executable: str = "powershell.exe",
        timeout_s: int = 20,
        default_compose_text: str = "Draft generated by DesktopAI.",
        state_store=None,
        ollama=None,
    ) -> None:
        self._timeout_s = max(1, int(timeout_s))
        self._default_compose_text = default_compose_text.strip() or "Draft generated by DesktopAI."
        self._is_windows = _is_windows_platform()
        self._powershell = self._resolve_powershell(powershell_executable)
        self._state_store = state_store
        self._ollama = ollama

    def _resolve_powershell(self, preferred: str) -> Optional[str]:
        candidates = [preferred, "powershell.exe", "pwsh.exe", "powershell", "pwsh"]
        for candidate in candidates:
            if not candidate:
                continue
            resolved = shutil.which(candidate)
            if resolved:
                return resolved
        return None

    async def execute(
        self,
        action: TaskAction,
        *,
        objective: str,
        desktop_context: Optional[DesktopContext] = None,
    ) -> ActionExecutionResult:
        if not self._is_windows:
            return ActionExecutionResult(
                ok=False,
                error="windows powershell executor requires Windows host",
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        if not self._powershell:
            return ActionExecutionResult(
                ok=False,
                error="powershell executable not found",
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        try:
            output = await self._execute_action(action, objective=objective, desktop_context=desktop_context)
        except Exception as exc:
            return ActionExecutionResult(
                ok=False,
                error=str(exc),
                result={
                    "executor": self.mode,
                    "mode": self.mode,
                    "action": action.action,
                    "ok": False,
                },
            )

        return ActionExecutionResult(
            ok=True,
            result={
                "executor": self.mode,
                "mode": self.mode,
                "action": action.action,
                "ok": True,
                "output": output,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            },
        )

    async def _execute_action(
        self,
        action: TaskAction,
        *,
        objective: str,
        desktop_context: Optional[DesktopContext] = None,
    ) -> str:
        name = (action.action or "").strip()
        params = dict(action.parameters or {})
        self._validate_command_input(name)

        if name == "observe_desktop":
            if desktop_context is not None:
                return json.dumps({
                    "window_title": desktop_context.window_title,
                    "process": desktop_context.process_exe,
                    "uia_summary": desktop_context.uia_summary,
                    "screenshot_available": desktop_context.screenshot_b64 is not None,
                })
            script = (
                "$ErrorActionPreference='Stop'; "
                "Add-Type -TypeDefinition \"using System;using System.Runtime.InteropServices;"
                "using System.Text;public static class U32{[DllImport('user32.dll')]public static extern IntPtr GetForegroundWindow();"
                "[DllImport('user32.dll',SetLastError=true)]public static extern int GetWindowText(IntPtr hWnd,StringBuilder text,int count);}\"\n"
                "$h=[U32]::GetForegroundWindow();$sb=New-Object System.Text.StringBuilder 1024;"
                "[void][U32]::GetWindowText($h,$sb,$sb.Capacity);$sb.ToString()"
            )
            return await self._run_powershell(script)

        if name == "open_application":
            app = str(params.get("application", "")).strip() or "outlook.exe"
            app = self._map_application_alias(app)
            script = (
                "$ErrorActionPreference='Stop'; "
                f"Start-Process -FilePath {self._ps_quote_app_name(app)}; "
                "Start-Sleep -Milliseconds 600; "
                f"Write-Output {self._ps_quote(f'started:{app}')}"
            )
            return await self._run_powershell(script)

        if name == "focus_search":
            keys = str(params.get("keys", "^f"))
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "compose_text":
            text = str(params.get("text", "")).strip()
            if not text and self._ollama and desktop_context:
                text = await self._generate_compose_text(objective, desktop_context) or ""
            if not text:
                text = f"{self._default_compose_text} ({objective})"
            keys = self._encode_sendkeys_text(text)
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "send_or_submit":
            keys = str(params.get("keys", "^{ENTER}"))
            script = self._send_keys_script(keys)
            return await self._run_powershell(script)

        if name == "verify_outcome":
            if desktop_context and self._state_store:
                after_event = await self._state_store.current()
                if after_event:
                    from ..desktop_context import DesktopContext as DC
                    after_ctx = DC.from_event(after_event)
                    if after_ctx:
                        changes = _detect_changes(desktop_context, after_ctx)
                        if changes:
                            return f"verified: {changes}"
                        return "verified: no observable state change"
            script = "$ErrorActionPreference='Stop'; Start-Sleep -Milliseconds 200; Write-Output 'verified'"
            return await self._run_powershell(script)

        raise RuntimeError(f"unhandled action: {name}")

    async def _generate_compose_text(self, objective: str, desktop_context) -> Optional[str]:
        try:
            prompt = (
                f"Draft a concise response for the following objective.\n\n"
                f"Objective: {objective}\n\n"
                f"Desktop Context:\n{desktop_context.to_llm_prompt()}\n\n"
                f"Write only the text to type. No explanation."
            )
            messages = [{"role": "user", "content": prompt}]
            screenshot_bytes = desktop_context.get_screenshot_bytes()
            if screenshot_bytes and hasattr(self._ollama, "chat_with_images"):
                result = await self._ollama.chat_with_images(messages, [screenshot_bytes])
            elif hasattr(self._ollama, "chat"):
                result = await self._ollama.chat(messages)
            else:
                result = await self._ollama.generate(prompt)
            if result and result.strip():
                return result.strip()
        except Exception as exc:
            logger.warning("LLM compose_text failed, using default: %s", exc)
        return None

    def _send_keys_script(self, keys: str) -> str:
        return (
            "$ErrorActionPreference='Stop'; "
            "$ws=New-Object -ComObject WScript.Shell; "
            "Start-Sleep -Milliseconds 150; "
            f"$ws.SendKeys({self._ps_quote(keys)}); "
            f"Write-Output {self._ps_quote(f'sent-keys:{keys}')}"
        )

    def _run_powershell_blocking(self, script: str) -> str:
        if not self._powershell:
            raise RuntimeError("powershell executable not found")
        proc = subprocess.run(
            [
                self._powershell,
                "-NoProfile",
                "-NonInteractive",
                "-ExecutionPolicy",
                "Bypass",
                "-Command",
                script,
            ],
            capture_output=True,
            text=True,
            timeout=self._timeout_s,
            check=False,
        )
        stdout = (proc.stdout or "").strip()
        stderr = (proc.stderr or "").strip()
        if proc.returncode != 0:
            detail = stderr or stdout or f"exit code {proc.returncode}"
            raise RuntimeError(detail)
        return stdout

    async def _run_powershell(self, script: str) -> str:
        return await asyncio.to_thread(self._run_powershell_blocking, script)

    _VALID_ACTIONS = frozenset({
        "observe_desktop", "open_application", "focus_search",
        "compose_text", "send_or_submit", "verify_outcome",
    })
    _PS_MAX_VALUE_LEN = 8192

    def _validate_command_input(self, action_name: str) -> None:
        if action_name not in self._VALID_ACTIONS:
            raise RuntimeError(f"unsupported action for windows executor: {action_name}")

    _PS_METACHARACTERS = frozenset("$`|&;")

    def _ps_quote(self, value: str) -> str:
        if "\x00" in value:
            raise ValueError("PowerShell input must not contain null bytes")
        if len(value) > self._PS_MAX_VALUE_LEN:
            raise ValueError(
                f"PowerShell input too long ({len(value)} chars, max {self._PS_MAX_VALUE_LEN})"
            )
        return "'" + value.replace("'", "''") + "'"

    def _ps_quote_app_name(self, value: str) -> str:
        """Quote an application name for Start-Process, rejecting metacharacters.

        Application names passed to Start-Process -FilePath should never contain
        PowerShell metacharacters ($, `, |, &, ;) as these could allow command
        injection even inside single quotes in certain contexts.
        """
        bad = self._PS_METACHARACTERS.intersection(value)
        if bad:
            raise ValueError(
                f"PowerShell metacharacter(s) {bad!r} in application name"
            )
        return self._ps_quote(value)

    def _map_application_alias(self, value: str) -> str:
        aliases = {
            "outlook": "outlook.exe",
            "vscode": "Code.exe",
            "code": "Code.exe",
            "notepad": "notepad.exe",
            "chrome": "chrome.exe",
            "edge": "msedge.exe",
            "teams": "ms-teams.exe",
        }
        key = value.strip().lower()
        return aliases.get(key, value)

    def _encode_sendkeys_text(self, text: str) -> str:
        encoded = []
        special = {"+", "^", "%", "~", "(", ")", "[", "]", "{", "}"}
        for ch in text:
            if ch == "\r":
                continue
            if ch == "\n":
                encoded.append("{ENTER}")
                continue
            if ch in special:
                encoded.append(f"{{{ch}}}")
                continue
            encoded.append(ch)
        return "".join(encoded)

    def status(self) -> Dict[str, Any]:
        available = self._is_windows and self._powershell is not None
        if not self._is_windows:
            message = "Windows-only executor unavailable on non-Windows host."
        elif self._powershell:
            message = "Windows PowerShell executor ready."
        else:
            message = "Windows PowerShell executor unavailable."

        return {
            "mode": self.mode,
            "available": available,
            "powershell": self._powershell,
            "timeout_s": self._timeout_s,
            "message": message,
        }

    async def preflight(self) -> Dict[str, Any]:
        checks: list[Dict[str, Any]] = []

        windows_ok = bool(self._is_windows)
        checks.append(
            {
                "name": "windows_host",
                "ok": windows_ok,
                "detail": "Windows host detected." if windows_ok else "Non-Windows host detected.",
            }
        )
        if not windows_ok:
            return {
                "mode": self.mode,
                "ok": False,
                "checks": checks,
                "message": "Windows preflight failed: non-Windows host.",
            }

        powershell_ok = self._powershell is not None
        checks.append(
            {
                "name": "powershell_available",
                "ok": powershell_ok,
                "detail": self._powershell or "PowerShell executable not found.",
            }
        )
        if not powershell_ok:
            return {
                "mode": self.mode,
                "ok": False,
                "checks": checks,
                "message": "Windows preflight failed: PowerShell not available.",
            }

        async def _run_check(name: str, script: str, success_detail: str) -> None:
            try:
                output = await self._run_powershell(script)
                checks.append(
                    {
                        "name": name,
                        "ok": True,
                        "detail": output or success_detail,
                    }
                )
            except Exception as exc:
                checks.append(
                    {
                        "name": name,
                        "ok": False,
                        "detail": str(exc),
                    }
                )

        await _run_check(
            "powershell_roundtrip",
            "$ErrorActionPreference='Stop'; Write-Output 'desktopai-preflight-ok'",
            "PowerShell command roundtrip succeeded.",
        )
        await _run_check(
            "wscript_shell_com",
            (
                "$ErrorActionPreference='Stop'; "
                "$ws=New-Object -ComObject WScript.Shell; "
                "if ($null -eq $ws) { throw 'WScript.Shell unavailable' }; "
                "Write-Output 'wscript-shell-ok'"
            ),
            "WScript.Shell COM available.",
        )

        ok = all(bool(item.get("ok")) for item in checks)
        return {
            "mode": self.mode,
            "ok": ok,
            "checks": checks,
            "message": "Windows preflight passed." if ok else "Windows preflight failed.",
        }
